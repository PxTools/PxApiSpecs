/* tslint:disable */
/* eslint-disable */
/**
 * PxApi
 * This api lets you do 2 things; Find a table(Navigation) and use a table (Table).  _Table below is added to show how tables can be described in yml._  **Table contains status code this API may return** | Status code    | Description      | Reason                      | | -------        | -----------      | ---------------------       | | 200            | Success          | The endpoint has delivered response for the request                      | | 400            | Bad request      | If the request is not valid | | 403            | Forbidden        | number of cells exceed the API limit | | 404            | Not found        | If the URL in request does not exist | | 429            | Too many request | Requests exceed the API time limit. Large queries should be run in sequence | | 50X            | Internal Server Error | The service might be down | 
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
import type { Adjustment } from './Adjustment';
import {
    AdjustmentFromJSON,
    AdjustmentFromJSONTyped,
    AdjustmentToJSON,
    AdjustmentToJSONTyped,
} from './Adjustment';
import type { CodeListInformation } from './CodeListInformation';
import {
    CodeListInformationFromJSON,
    CodeListInformationFromJSONTyped,
    CodeListInformationToJSON,
    CodeListInformationToJSONTyped,
} from './CodeListInformation';
import type { MeasuringType } from './MeasuringType';
import {
    MeasuringTypeFromJSON,
    MeasuringTypeFromJSONTyped,
    MeasuringTypeToJSON,
    MeasuringTypeToJSONTyped,
} from './MeasuringType';
import type { PriceType } from './PriceType';
import {
    PriceTypeFromJSON,
    PriceTypeFromJSONTyped,
    PriceTypeToJSON,
    PriceTypeToJSONTyped,
} from './PriceType';

/**
 * extension at dimension
 * @export
 * @interface ExtensionDimension
 */
export interface ExtensionDimension {
    /**
     * Can dimension be elminated
     * @type {boolean}
     * @memberof ExtensionDimension
     */
    elimination?: boolean;
    /**
     * Elimination value code
     * @type {string}
     * @memberof ExtensionDimension
     */
    eliminationValueCode?: string;
    /**
     * Describes if a note of a certain index is mandatory.
     * @type {{ [key: string]: boolean; }}
     * @memberof ExtensionDimension
     */
    noteMandatory?: { [key: string]: boolean; };
    /**
     * Describes which value note are mandatory
     * @type {{ [key: string]: { [key: string]: boolean; }; }}
     * @memberof ExtensionDimension
     */
    categoryNoteMandatory?: { [key: string]: { [key: string]: boolean; }; };
    /**
     * Text with information on the exact period for the statistics
     * @type {{ [key: string]: string; }}
     * @memberof ExtensionDimension
     */
    refperiod?: { [key: string]: string; };
    /**
     * Information about how variables are presented
     * @type {string}
     * @memberof ExtensionDimension
     */
    show?: string;
    /**
     * Available codelists for this dimension
     * @type {Array<CodeListInformation>}
     * @memberof ExtensionDimension
     */
    codeLists?: Array<CodeListInformation>;
    /**
     * Indicates if data is stock, flow or average.
     * @type {{ [key: string]: MeasuringType; }}
     * @memberof ExtensionDimension
     */
    measuringType?: { [key: string]: MeasuringType; };
    /**
     * Indicates if data is in current or fixed prices.
     * @type {{ [key: string]: PriceType; }}
     * @memberof ExtensionDimension
     */
    priceType?: { [key: string]: PriceType; };
    /**
     * Describes adjustments made to the data
     * @type {{ [key: string]: Adjustment; }}
     * @memberof ExtensionDimension
     */
    adjustment?: { [key: string]: Adjustment; };
    /**
     * Base period for, for instance index series. Is shown with the footnote. If there is a contents variable the keyword is repeated for each value of the contents variable.
     * @type {{ [key: string]: string; }}
     * @memberof ExtensionDimension
     */
    basePeriod?: { [key: string]: string; };
}

/**
 * Check if a given object implements the ExtensionDimension interface.
 */
export function instanceOfExtensionDimension(value: object): value is ExtensionDimension {
    return true;
}

export function ExtensionDimensionFromJSON(json: any): ExtensionDimension {
    return ExtensionDimensionFromJSONTyped(json, false);
}

export function ExtensionDimensionFromJSONTyped(json: any, ignoreDiscriminator: boolean): ExtensionDimension {
    if (json == null) {
        return json;
    }
    return {
        
        'elimination': json['elimination'] == null ? undefined : json['elimination'],
        'eliminationValueCode': json['eliminationValueCode'] == null ? undefined : json['eliminationValueCode'],
        'noteMandatory': json['noteMandatory'] == null ? undefined : json['noteMandatory'],
        'categoryNoteMandatory': json['categoryNoteMandatory'] == null ? undefined : json['categoryNoteMandatory'],
        'refperiod': json['refperiod'] == null ? undefined : json['refperiod'],
        'show': json['show'] == null ? undefined : json['show'],
        'codeLists': json['codeLists'] == null ? undefined : ((json['codeLists'] as Array<any>).map(CodeListInformationFromJSON)),
        'measuringType': json['measuringType'] == null ? undefined : (mapValues(json['measuringType'], MeasuringTypeFromJSON)),
        'priceType': json['priceType'] == null ? undefined : (mapValues(json['priceType'], PriceTypeFromJSON)),
        'adjustment': json['adjustment'] == null ? undefined : (mapValues(json['adjustment'], AdjustmentFromJSON)),
        'basePeriod': json['basePeriod'] == null ? undefined : json['basePeriod'],
    };
}

export function ExtensionDimensionToJSON(json: any): ExtensionDimension {
    return ExtensionDimensionToJSONTyped(json, false);
}

export function ExtensionDimensionToJSONTyped(value?: ExtensionDimension | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }

    return {
        
        'elimination': value['elimination'],
        'eliminationValueCode': value['eliminationValueCode'],
        'noteMandatory': value['noteMandatory'],
        'categoryNoteMandatory': value['categoryNoteMandatory'],
        'refperiod': value['refperiod'],
        'show': value['show'],
        'codeLists': value['codeLists'] == null ? undefined : ((value['codeLists'] as Array<any>).map(CodeListInformationToJSON)),
        'measuringType': value['measuringType'] == null ? undefined : (mapValues(value['measuringType'], MeasuringTypeToJSON)),
        'priceType': value['priceType'] == null ? undefined : (mapValues(value['priceType'], PriceTypeToJSON)),
        'adjustment': value['adjustment'] == null ? undefined : (mapValues(value['adjustment'], AdjustmentToJSON)),
        'basePeriod': value['basePeriod'],
    };
}

